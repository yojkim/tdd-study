## 30. 디자인 패턴
   
### 패턴에 대한 통찰
- 문제의 대다수는 도구에 의해 생기는 것  
  => 외부적 문제 해결 컨텍스트가 엄청나게 다양하더라도 공통의 해결책을 가진 공통의 문제를 발견할 수 있음
- 객체를 적용해서 계산을 조직화하는 것은 내부의 공통적이고 부차적인 문제들을 공통적인 방법으로 해결할 수 해결하는 가장 좋은 예시
- 디자인 패턴은 이러한 공통적인 해결 방법들에 대한 매우 성공적인 사례

### 커맨드
- 계산 작업에 대한 호출을 메시지가 아닌 객체로 표현
- 복잡한 계산 작업 호출은 값비싼 메커니즘을 필요로 함  
  => 그러나 대부분의 경우 이런 모든 복잡함이 요구되지는 않음
- 메시지 하나를 보내는 것보다 호출이 조금 더 구체적이고 조작하기 쉬워지기 위해 객체를 사용

### 값 객체
- 객체가 생성된 이후 그 값이 절대로 변하지 않게 하여 별칭 문제가 발생하지 않게 함
- 공유해야하지만 동일성은 중요하지 않을 때 객체의 상태를 설정한 후 절대로 변할 수 없도록 설계  
  => 객체에 대해 수행되는 연산은 언제나 새로운 객체를 반환하도록 함
- 별칭 문제를 해결할 방법은 여러 가지가 있음  
  1. 객체에 대한 참조를 외부로 알리지 않는 방법  
   => 객체에 대한 복사본을 제공하지만 오버헤드가 크고 상태 변경사항에 대한 공유가 어려움
  2. 의존하는 객체에 자기를 등록해두고 객체의 상태가 변하면 통지를 받는 **옵저버 패턴**  
   => 제어 흐름을 이해하기 어렵게 만들 수 있고, 의존성 통제에 대한 로직이 지저분해질 수 있음
  3. 오퍼레이션을 거치면 새로운 객체를 반환하도록하여 원래의 상태에는 영향을 주지 않게 하는 방법  
   => 같은 역할을 지칭하는 **동등성**을 구현해야 함

### 널 객체
- 계산 작업의 기본 사례를 객체로 표현
- 예외가 발생했을 시 설정하는 **default**값을 예로 들 수 있음

### 템플릿 메서드
- 계산 작업의 변하지 않는 순서를 여러 추상 메서드로 표현  
  => 상속을 통해 특정 작업을 수행하게끔 구체화
- 상위 클래스에는 메서드 호출만 하고 하위 클래스에서 메서드를 서로 다른 방식으로 구현하여 순서를 조절할 수 있음
- 둘 이상의 메서드들 사이의 다른 부분을 추출하고나면 템플릿 메서드가 남음  
  => 템플릿 메서드를 상위 클래스로 보내고 중복을 제거할 수 있음

### 플러거블 객체
- 둘 이상의 구현을 객체를 호출함으로써 다양성을 표현
- 명시적인 조건문으로 다양성을 표현할 수 있지만 조건이 퍼져나갈수록 중복이 발생하고 코드가 복잡해짐
- 플러거블 객체가 인터페이스를 구현하게하여 조건문을 대신하게 함

### 플러거블 셀렉터
- 객체별로 서로 다른 메서드가 동적으로 호출되게하여 필요 없는 하위 클래스의 생성을 피함
- **switch**문을 사용할 수 있지만 이 경우 메서드의 이름이 여러 곳에 나뉘어 존재하게 됨
- 직관적인 상황에서 코드를 정리하는 용도로만 사용할 것

### 팩토리 메서드
- 생성자 대신 메서드를 호출하여 객체를 생성  
  => 새 객체에 유연성을 원할 경우 사용
- 유연함이 필요 없을 때에는 굳이 생성자를 쓰지 않고 팩토리 메서드를 쓸 이유는 없음

### 사칭 사기꾼(임포스터)
- 현존하는 프로토콜을 갖는 다른 구현을 추가하여 시스템에 변이를 도입
- 이미 정상적으로 동작하는 메서드에 대한 변화를 요구할 때 사용
- 널 객체와 컴포지트는 사칭 사기꾼의 대표적인 예시
- 리팩토링중에 사칭 사기꾼을 잡아내는 작업은 중복 제거를 통해 유도됨

### 컴포지트
- 하나의 객체로 여러 객체의 행위 조합을 표현
- 실제 동작에서는 필요가 없을 수도 있으나 설계상에서의 편의와 구조에서의 중복 제거에 용이함

### 수집 매개변수
- 여러 다른 객체에서 계산한 결과를 모으기 위해 매개변수를 여러 곳으로 전달  
  => 결과가 수집될 객체를 각 오퍼레이션의 매개변수로 추가

### 싱글톤
- 전역 변수를 제공하지 않는 언어에서 전역 변수를 사용하려면?  
  => 사용하지 말고 대신 설계에 대해 고민할 것